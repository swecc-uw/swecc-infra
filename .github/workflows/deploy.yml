name: Deploy Swarm Stack
on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on:
      group: EC2
      labels: [self-hosted, deploy]
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v2
      
    - name: Initialize Swarm if needed
      run: |
        if ! docker info | grep -q "Swarm: active"; then
          docker swarm init
        fi
        
    - name: Create or update network if needed
      run: |
        if ! docker network ls | grep -q "swecc_stack_swecc-network"; then
          docker network create --driver overlay --attachable swecc-network
        fi

    - name: Extract current configs for comparison
      run: |
        mkdir -p old_configs
        
        # Function to extract current config content
        extract_config() {
          local config_name=$1
          if docker config ls --filter name=$config_name -q | grep -q .; then
            docker config inspect $config_name --pretty | sed -n '/Data:/,$ p' | sed '1d' > old_configs/${config_name}.txt
          else
            touch old_configs/${config_name}.txt
          fi
        }

        # Extract current configs
        extract_config "bot_env"
        extract_config "chronos_env"
        extract_config "scheduler_env"
        extract_config "server_env"
        extract_config "sockets_env"

    - name: Create new environment configs
      run: |
        mkdir -p new_configs

        # Create new config content files
        cat << EOF > new_configs/bot_env.txt
        DISCORD_TOKEN=${{ secrets.DISCORD_TOKEN }}
        SWECC_SERVER=${{ secrets.SWECC_SERVER }}
        ADMIN_CHANNEL=${{ secrets.ADMIN_CHANNEL }}
        LC_CHANNEL_ID=${{ secrets.LC_CHANNEL_ID }}
        TRANSCRIPTS_CHANNEL=${{ secrets.TRANSCRIPTS_CHANNEL }}
        SWECC_API_KEY=${{ secrets.SWECC_API_KEY }}
        SWECC_URL=${{ secrets.SWECC_URL }}
        PREFIX_COMMAND=${{ secrets.PREFIX_COMMAND }}
        SWECC_RESUME_CHANNEL=${{ secrets.SWECC_RESUME_CHANNEL }}
        CALENDAR_URL=${{ secrets.CALENDAR_URL }}
        AOC_LEADERBOARD_ID=${{ secrets.AOC_LEADERBOARD_ID }}
        AOC_SESSION=${{ secrets.AOC_SESSION }}
        AOC_LEADERBOARD_KEY=${{ secrets.AOC_LEADERBOARD_KEY }}
        INTERNSHIP_CHANNEL_ID=${{ secrets.INTERNSHIP_CHANNEL_ID }}
        NEW_GRAD_CHANNEL_ID=${{ secrets.NEW_GRAD_CHANNEL_ID }}
        GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}
        OFF_TOPIC_CHANNEL_ID=${{ secrets.OFF_TOPIC_CHANNEL_ID }}
        OFFICER_ROLE_ID=${{ secrets.OFFICER_ROLE_ID }}
        VERIFIED_ROLE_ID=${{ secrets.VERIFIED_ROLE_ID }}
        EOF
        
        cat << EOF > new_configs/chronos_env.txt
        AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_DEFAULT_REGION=${{ secrets.AWS_DEFAULT_REGION }}
        EOF

        cat << EOF > new_configs/scheduler_env.txt
        ENV=prod
        SCHEDULER_API_KEY=${{ secrets.SCHEDULER_API_KEY }}
        EOF

        cat << EOF > new_configs/server_env.txt
        DJANGO_DEBUG=${{ secrets.DJANGO_DEBUG }}
        DB_HOST=${{ secrets.DB_HOST }}
        DB_NAME=${{ secrets.DB_NAME }}
        DB_PORT=${{ secrets.DB_PORT }}
        DB_USER=${{ secrets.DB_USER }}
        DB_PASSWORD=${{ secrets.DB_PASSWORD }}
        SENDGRID_API_KEY=${{ secrets.SENDGRID_API_KEY }}
        SUPABASE_URL=${{ secrets.SUPABASE_URL }}
        SUPABASE_KEY=${{ secrets.SUPABASE_KEY }}
        INTERNSHIP_CHANNEL_ID=${{ secrets.INTERNSHIP_CHANNEL_ID }}
        NEW_GRAD_CHANNEL_ID=${{ secrets.NEW_GRAD_CHANNEL_ID }}
        METRIC_SERVER_URL=${{ secrets.METRIC_SERVER_URL }}
        JWT_SECRET=${{ secrets.JWT_SECRET }}
        EOF

        cat << EOF > new_configs/sockets_env.txt
        DB_HOST=${{ secrets.DB_HOST }}
        DB_NAME=${{ secrets.DB_NAME }}
        DB_PORT=${{ secrets.DB_PORT }}
        DB_USER=${{ secrets.DB_USER }}
        DB_PASSWORD=${{ secrets.DB_PASSWORD }}
        JWT_SECRET=${{ secrets.JWT_SECRET }}
        EOF

    - name: Detect config changes and remove affected services
      run: |
        mkdir -p services_to_recreate

        # Function to check if config has changed
        check_config_change() {
          local service_name=$1
          local config_name=$2
          local service_full_name="swecc_stack_$service_name"

          # Compare old and new configs
          if ! diff -q old_configs/${config_name}.txt new_configs/${config_name}.txt > /dev/null; then
            echo "Config for $service_name has changed."

            # Mark service for recreation
            touch services_to_recreate/$service_name

            # Remove the service if it exists
            if docker service ls --filter name=$service_full_name -q | grep -q .; then
              echo "Removing $service_full_name to apply config changes..."
              docker service rm $service_full_name
            fi
          else
            echo "No changes detected for $service_name config."
          fi
        }

        # Check for config changes
        check_config_change "bot" "bot_env"
        check_config_change "chronos" "chronos_env"
        check_config_change "scheduler" "scheduler_env"
        check_config_change "server" "server_env"
        check_config_change "sockets" "sockets_env"

        # Update Docker configs
        for config_name in bot_env chronos_env scheduler_env server_env sockets_env; do
          docker config rm $config_name 2>/dev/null || true
          docker config create $config_name new_configs/${config_name}.txt
        done

    - name: Log in to Docker Hub for private images
      run: |
        echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login --username "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin

    - name: Deploy stack
      run: |
        # Deploy or update the stack
        docker stack deploy -c stack.yml --with-registry-auth --prune swecc_stack
        
        # Verify deployment
        echo "Stack deployed. Current services:"
        docker service ls

    - name: Clean up
      run: |
        # Remove temporary directories
        rm -rf old_configs
        rm -rf new_configs
        rm -rf services_to_recreate