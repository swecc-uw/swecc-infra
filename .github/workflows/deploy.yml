name: Deploy Swarm Stack
on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on:
      group: EC2
      labels: [self-hosted, deploy]
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v2
      
    - name: Initialize Swarm if needed
      run: |
        if ! docker info | grep -q "Swarm: active"; then
          docker swarm init
        fi
        
    - name: Create or update network if needed
      run: |
        if ! docker network ls | grep -q "swecc_stack_swecc-network"; then
          docker network create --driver overlay --attachable swecc-network
        fi

    - name: Create environment files as Docker configs
      run: |
        # Remove existing configs if they exist
        docker config rm bot_env chronos_env scheduler_env server_env sockets_env 2>/dev/null || true
        
        # Create configs for each service
        cat << EOF > bot.env
        DISCORD_TOKEN=${{ secrets.DISCORD_TOKEN }}
        SWECC_SERVER=${{ secrets.SWECC_SERVER }}
        ADMIN_CHANNEL=${{ secrets.ADMIN_CHANNEL }}
        LC_CHANNEL_ID=${{ secrets.LC_CHANNEL_ID }}
        TRANSCRIPTS_CHANNEL=${{ secrets.TRANSCRIPTS_CHANNEL }}
        SWECC_API_KEY=${{ secrets.SWECC_API_KEY }}
        SWECC_URL=${{ secrets.SWECC_URL }}
        PREFIX_COMMAND=${{ secrets.PREFIX_COMMAND }}
        SWECC_RESUME_CHANNEL=${{ secrets.SWECC_RESUME_CHANNEL }}
        CALENDAR_URL=${{ secrets.CALENDAR_URL }}
        AOC_LEADERBOARD_ID=${{ secrets.AOC_LEADERBOARD_ID }}
        AOC_SESSION=${{ secrets.AOC_SESSION }}
        AOC_LEADERBOARD_KEY=${{ secrets.AOC_LEADERBOARD_KEY }}
        INTERNSHIP_CHANNEL_ID=${{ secrets.INTERNSHIP_CHANNEL_ID }}
        NEW_GRAD_CHANNEL_ID=${{ secrets.NEW_GRAD_CHANNEL_ID }}
        GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}
        OFF_TOPIC_CHANNEL_ID=${{ secrets.OFF_TOPIC_CHANNEL_ID }}
        OFFICER_ROLE_ID=${{ secrets.OFFICER_ROLE_ID }}
        VERIFIED_ROLE_ID=${{ secrets.VERIFIED_ROLE_ID }}
        EOF
        docker config create bot_env bot.env
        
        cat << EOF > chronos.env
        AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_DEFAULT_REGION=${{ secrets.AWS_DEFAULT_REGION }}
        EOF
        docker config create chronos_env chronos.env

        cat << EOF > scheduler.env
        ENV=prod
        SCHEDULER_API_KEY=${{ secrets.SCHEDULER_API_KEY }}
        EOF
        docker config create scheduler_env scheduler.env

        cat << EOF > server.env
        DJANGO_DEBUG=${{ secrets.DJANGO_DEBUG }}
        DB_HOST=${{ secrets.DB_HOST }}
        DB_NAME=${{ secrets.DB_NAME }}
        DB_PORT=${{ secrets.DB_PORT }}
        DB_USER=${{ secrets.DB_USER }}
        DB_PASSWORD=${{ secrets.DB_PASSWORD }}
        SENDGRID_API_KEY=${{ secrets.SENDGRID_API_KEY }}
        SUPABASE_URL=${{ secrets.SUPABASE_URL }}
        SUPABASE_KEY=${{ secrets.SUPABASE_KEY }}
        INTERNSHIP_CHANNEL_ID=${{ secrets.INTERNSHIP_CHANNEL_ID }}
        NEW_GRAD_CHANNEL_ID=${{ secrets.NEW_GRAD_CHANNEL_ID }}
        METRIC_SERVER_URL=${{ secrets.METRIC_SERVER_URL }}
        JWT_SECRET=${{ secrets.JWT_SECRET }}
        EOF
        docker config create server_env server.env

        cat << EOF > sockets.env
        DB_HOST=${{ secrets.DB_HOST }}
        DB_NAME=${{ secrets.DB_NAME }}
        DB_PORT=${{ secrets.DB_PORT }}
        DB_USER=${{ secrets.DB_USER }}
        DB_PASSWORD=${{ secrets.DB_PASSWORD }}
        JWT_SECRET=${{ secrets.JWT_SECRET }}
        EOF
        docker config create sockets_env sockets.env

        # Clean up local files
        rm *.env

    - name: Log in to Docker Hub for private images
      run: |
        echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login --username "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin

    - name: Deploy stack
      run: |
        # Deploy or update the stack
        docker stack deploy -c stack.yml --with-registry-auth --prune swecc_stack
        
        # Verify deployment
        echo "Stack deployed. Current services:"
        docker service ls

    - name: Update services with latest configs
      run: |
        # Function to update a service with its latest config
        update_service_with_config() {
          local service_name=$1
          local config_name=$2
          local service_full_name="swecc_stack_$service_name"

          # Check if service exists
          if docker service ls --filter name=$service_full_name -q | grep -q .; then
            echo "Updating $service_full_name with latest $config_name config..."

            # Extract environment variables from config to file
            docker config inspect $config_name --pretty | sed -n '/Data:/,$ p' | sed '1d' > ${service_name}_env.txt

            # Update the service with the env file
            docker service update \
              --env-file ${service_name}_env.txt \
              --force \
              $service_full_name

            # Clean up
            rm ${service_name}_env.txt
          else
            echo "Service $service_full_name does not exist, skipping update."
          fi
        }

        # Wait for stack deployment to complete
        echo "Waiting for stack deployment to stabilize..."
        sleep 10

        # Update services with their configs
        update_service_with_config "bot" "bot_env"
        update_service_with_config "chronos" "chronos_env"
        update_service_with_config "scheduler" "scheduler_env"
        update_service_with_config "server" "server_env"
        update_service_with_config "sockets" "sockets_env"